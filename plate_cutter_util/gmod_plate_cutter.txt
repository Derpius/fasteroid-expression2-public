@name Gmod Hunter Plate Cutter v2.4
@inputs 
@outputs 
@persist Ang Busy Mask:table RemoveThis:entity Entity:entity Mode:string Owner:entity ChangedMode Modes:table HoleModeState HoleData:table PropData:table
@persist [FlatMin,FlatSize,Origin,Forward,Up,SpawnComplement,WorldPos,SpawnPos]:vector Valid
@model models/hunter/blocks/cube025x025x025.mdl

#[
    Note for Fasteroid/expression2-public Github browsers: 
    
    This chip won't work without its #includes and supporting database.
    
    The includes can all be found alongside this file in plate_cutter_util/*.txt
    Just install them under the same location in your E2 folder and you should be good to go.
    
    Additionally, you'll need to pick up a copy of hunterplates_sorted.txt from my e2shared directory:
    https://github.com/Fasteroid/expression2-public/blob/master/e2shared/hunterplates_sorted.txt
    
]#

#include "plate_cutter_util/gmod_plate_database_sorted"
#include "plate_cutter_util/queuepropspawn"

if( first() ){
    
    Owner = owner()
    Mode  = "slice"
    Modes = table("slice"=1, "hole"=1)
    HoleModeState = 0
    
    print("--------------------------------\n- Fast's Hunter Plate Cutter -\n--------------------------------\n")
    print("Supported modes:")
    foreach(N,S:string = Modes:keys()){
        print("/"+S)
    }
    print("--------------------------------")
    
    function null(E:entity){}
    
    function err(Reason:string){
        holoEntity(0):soundPlay(2,1,"common/wpn_denyselect.wav")
        Busy = 0        
        print("[Prop Cutter] "+Reason)
    }
    
    propSpawnUndo(1)
    holoCreate(0)
    holoColor(0,vec(255,255,0),100)
    holoAng(0,ang())
    holoScaleUnits(0,vec(5))
    holoMaterial(0,"lights/white")
    holoEntity(0):setRenderMode(9)
    holoVisible(0,players(),0)
    
    #holoCreate(3)
    #holoModel(3,"models/sprops/misc/origin.mdl")
    
    holoCreate(1,entity():toWorld(vec()))
    holoModel(1,"plane")
    holoAng(1,ang(0,0,90))
    holoScaleUnits(1,vec(100,100,100))
    holoMaterial(1,"lights/white")
    holoColor(1,vec(255),100)
    holoEntity(1):setRenderMode(9)

    holoCreate(2)
    holoModel(2,"plane")
    holoAng(2,ang(0,0,-90))
    holoScaleUnits(2,vec(100,100,100))
    holoMaterial(2,"lights/white")
    holoColor(2,vec(60),200)
    holoEntity(2):setRenderMode(9)
    
    holoParent(1,0)
    holoParent(2,0)
    
    holoCreate(3)
    holoColor(3,vec(255,0,0),100)
    holoMaterial(3,"lights/white")

    #holoModel(1,"models/maxofs2d/cube_tool.mdl")
    #holoColor(1,vec(255,0,0),100)
    runOnTick(1)
    #holoScale(1,vec(10,0.01,10))
    
    
    #########################
    ## 
    #  build( XSize:numbner, YSize:number, Corner:vector, Options:optionsTable )
    #     Spawns a plate of XSize by YSize.   
    #
    #  optionsTable extends table:
    #   | "origin" = World position of corner
    #   | "angles" = World angles of corner
    #   | "format" = Function to format spawned props with
    #   | "delete" = Prop to remove upon completion; may be left blank
    #
    function build(XSize,YSize,Corner:vector,Options:table){
        
        PlateObj = getClosestFit(round(XSize),round(YSize))
        local LTX = LTY = 0
        local XReal = PlateObj["x",number]
        local YReal = PlateObj["y",number]
        local RotationAng = ang(0,PlateObj["angle",number],0)
        
        local World = toWorldPosAng( 
            (Corner)*UNIT_SIZE, # local pos
            RotationAng,                                  # local ang
            Options["origin",vector],                     # world pos
            Options["angles",angle]                       # world ang
        )
        
        queuePropSpawn(
            PlateObj["model",string],
            World[1,vector] + PlateObj["offset",vector]:rotate(Options["angles",angle]) * UNIT_SIZE,
            World[2,angle],
            Options["format",string]
        )
        
        if( XReal < XSize ){
            build(XSize-XReal,YReal,Corner+vec(XReal,0,0),Options)    
            LTX = 1
        }
        if( YReal < YSize ){
            build(XReal,YSize-YReal,Corner+vec(0,YReal,0),Options)
            LTY = 1
        }
        if( LTX & LTY ){ # degenerate case
            build(XSize-XReal,YSize-YReal,Corner+vec(XReal,YReal,0),Options)
        }  
    }    
    
    #########################
    ## 
    #  computeSnapping( )
    #     Predefines some variables.  Sorry they're global lol
    #    
    function computeSnapping(){
        
        Valid = Entity:model():find("models/hunter/plates") & !(Entity:model():find("tri")) & Entity:model():find("x")
        if(!Valid){
            return
        }
        
        FlatMin = Entity:boxMin():setZ(0)
        FlatSize = round( Entity:boxSize():setZ(0) / UNIT_SIZE )
        Origin = Entity:toWorld(FlatMin)
        
        Forward = Owner:aimNormal()
        Up      = Entity:right()
        
        local AngContext = quat(Forward,Up)
        TileAng = AngContext:toAngle()
        
        SpawnComplement = Entity:toLocal( Owner:aimPos() ) + FlatMin
        SpawnComplement = round( SpawnComplement / UNIT_SIZE )
        WorldPos = Entity:toWorld(SpawnComplement * UNIT_SIZE - FlatMin) 
        SpawnPos = round( Entity:boxSize():setZ(0) / UNIT_SIZE + SpawnComplement - 2 * Entity:boxCenter() / UNIT_SIZE )
        
    }
    
    function storePropData(E:entity){
        PropData["mat",string] = E:getMaterial()
        PropData["color",vector] = E:getColor()
        PropData["alpha",number] = E:getAlpha()
        #PropData["render",number] = E:getRenderMode() BOOO, THERE'S NO FUNCTION FOR THIS!
    }
    
    function applyPropData(E:entity){
        E:setMaterial( PropData["mat",string] )
        E:setColor( PropData["color",vector] )
        E:setAlpha( PropData["alpha",number])
    }
    
    # ------------ Mode Functions ------------ #
    
    #########################
    ## 
    #  slice( Init:boolean )
    #     Slicing mode.  Pass 1 to enable.
    #
    function slice(Init){
        
        if(Init){
            print("Mouse1 to slice along the cutting plane.\nMouse2 rotates the cutting plane.")
            holoVisible(1,players(),1)
            holoVisible(2,players(),1)
            holoVisible(0,players(),0)
            return
        }
        
        computeSnapping()
        
        if(!Entity){ return }

        if(changed(Entity)){
            if( Valid ){
                holoPos(3,Entity:boxCenterW())
                holoAng(3,Entity:angles())
                holoScaleUnits(3,Entity:boxSize())    
                holoParent(3,Entity)
            }
            else{
                holoScale(3,vec(0))
            }
        }
        
        holoPos(0,WorldPos)
        holoAng(0,TileAng:rotateAroundAxis(Forward,Ang))   
                

        if(changed(Owner:keyAttack1()) & Owner:keyAttack1()){
            
            if(!Valid){
                err("Sorry, that prop is not supported (yet)")
                return
            }
            
            Busy = 1
            storePropData(Entity)
            if(Ang == 0 | Ang == 180){
                if( !SpawnPos[1] | !(FlatSize[1]-SpawnPos[1]) | !(FlatSize[2]) ){
                    err("Nothing to cut here")
                    return
                }
                holoUnparent(3)
                build(SpawnPos[1],FlatSize[2],vec(),table(
                    "origin" = Origin,
                    "angles" = Entity:angles(),
                    "delete" = Entity,
                    "format" = "applyPropData"
                ))
    
                build(FlatSize[1]-SpawnPos[1],FlatSize[2],vec(),table(
                    "origin" = Entity:toWorld(FlatMin+vec(SpawnPos[1],0,0)*UNIT_SIZE),
                    "angles" = Entity:angles(),
                    "delete" = Entity,
                    "format" = "applyPropData"
                ))
            }
            elseif(Ang == 90 | Ang == 270){
                
                if( !FlatSize[1] | !(FlatSize[2]-SpawnPos[2]) | !(SpawnPos[2]) ){
                    err("Nothing to cut here")
                    return
                }
                holoUnparent(3)
                build(FlatSize[1],SpawnPos[2],vec(),table(
                    "origin" = Origin,
                    "angles" = Entity:angles(),
                    "delete" = Entity,
                    "format" = "applyPropData"
                ))
    
                build(FlatSize[1],FlatSize[2]-SpawnPos[2],vec(),table(
                    "origin" = Entity:toWorld(FlatMin+vec(0,SpawnPos[2],0)*UNIT_SIZE),
                    "angles" = Entity:angles(),
                    "delete" = Entity,
                    "format" = "applyPropData"
                ))
            } 
            holoEntity(0):soundPlay(1,1,"buttons/weapon_confirm.wav")
            soundPitch(1,180)
            return
        }
    }
    
    #########################
    ## 
    #  hole( Init:boolean )
    #     Hole cutter mode.  Pass 1 to enable.
    #
    function hole(Init){
        
        if(Init){
            print("Mouse1 to set corners.\nMouse2 will cancel a hole if the first corner is set.")
            holoVisible(1,players(),0)
            holoVisible(2,players(),0)
            holoVisible(0,players(),1)
            holoScaleUnits(0,vec(5))
            HoleModeState = 0
            return
        }
    
        KeyAttack1 = changed(Owner:keyAttack1()) & Owner:keyAttack1()
    
        if( HoleModeState == 0 ){
            
            computeSnapping()
            if(!Entity){ return }
            local EntChange = changed(Entity) 
            
            if( EntChange ){
                if( Valid ){
                    holoPos(3,Entity:boxCenterW())
                    holoAng(3,Entity:angles())
                    holoScaleUnits(3,Entity:boxSize())    
                    holoParent(3,Entity)
                }
                else{
                    holoScale(3,vec(0))
                }
            }
            
            if( EntChange | changed(SpawnComplement) ){
                holoPos(0,WorldPos)
                holoAng(0,TileAng)
                HoleData["pos",vector] = SpawnPos
                HoleData["complement",vector] = SpawnComplement
                HoleData["world",vector] = WorldPos
                HoleData["ent",entity] = Entity
                HoleData["entpos",vector] = Entity:pos()
            }
            
            if(KeyAttack1){
                if(!Valid){
                    err("Sorry, that prop is not supported (yet)")
                    return
                }
                HoleModeState++
                holoEntity(0):soundPlay(3,1,"buttons/lightswitch2.wav")
            }
            
        }
        else{
            
            if( HoleData["ent",entity] == Entity ){
                computeSnapping()
            }
            Entity = HoleData["ent",entity]
            
            if( HoleData["ent",entity]:pos() != HoleData["entpos",vector] ){    
                HoleModeState = 0
                holoScaleUnits(0,vec(UNIT_SIZE/2))
                print("Entity moved, hole aborted.")
                owner():soundPlay(404,1,"buttons/button10.wav")
                return
            }
            
            if( changed(SpawnComplement) ){
                holoPos(0,(HoleData["world",vector]+WorldPos)/2)
                holoScaleUnits(0,( positive(SpawnPos-HoleData["pos",vector]):rotate(ang(0,90,90)) + vec(1,0,0)) * UNIT_SIZE)
                holoAng(0,TileAng)
            }       
            
            if(changed(Owner:keyAttack2()) & Owner:keyAttack2()){
                HoleModeState = 0
                holoScaleUnits(0,vec(UNIT_SIZE/2))
                return
            }
            
            if(KeyAttack1){
                
                holoUnparent(3)
                
                HoleModeState = 0
                holoScaleUnits(0,vec(UNIT_SIZE/2))
                Busy = 1
                storePropData(Entity)
            
                local MinCorner = minVec(HoleData["pos",vector],SpawnPos)
                local MaxCorner = maxVec(HoleData["pos",vector],SpawnPos)
                local MinComplement = minVec(HoleData["complement",vector],SpawnComplement)
                local MaxComplement = maxVec(HoleData["complement",vector],SpawnComplement)
                
                local MinCorners = array(
                    vec(),
                    vec(MinCorner[1],0,0),
                    vec(MinCorner[1],FlatSize[2]+MaxComplement[2],0),
                    vec(MaxCorner[1],0,0)
                )
                
                local Sizes = array(
                    vec(MinCorner[1],FlatSize[2],0),
                    vec(MaxCorner[1]-MinCorner[1],FlatSize[2]+MinComplement[2],0),
                    vec(MaxCorner[1]-MinCorner[1],-MaxComplement[2],0),
                    FlatSize - vec(MaxCorner[1],0,0)
                )
                
                for(I=1, 4){
                    local Origin = Entity:toWorld(FlatMin + MinCorners[I,vector]*UNIT_SIZE)
                    local Size = Sizes[I,vector]
                    if(Size[1] & Size[2]){
                        build(Size[1],Size[2],vec(),table(
                            "origin" = Origin,
                            "angles" = Entity:angles(),
                            "delete" = Entity,
                            "format" = "applyPropData"
                        ))
                    }
                }
                
                holoEntity(0):soundPlay(1,1,"buttons/weapon_confirm.wav")
                soundPitch(1,180)
                
                return
    
            }              
        }
    }    
    
}

Owner = owner()
Active = (Owner:weapon():type() == "weapon_crowbar")
DoneBusy = !Queue:count() & Busy

if(changed(Mode) | first()){
    Mode(1)
}

if(DoneBusy){
    Busy = 0
    Entity:propDelete()    
}

if(Active & !Busy){
    
    if(changed(Owner:keyAttack2()) & Owner:keyAttack2()){
        Ang = (Ang + 90)%360
    }
    
    Entity = Owner:aimEntity()
     
    Mode(0)
    
    if(changed(Owner:lastSaidWhen())){
        Chat = Owner:lastSaid():explode(" ")
        if(Chat[1,string]=="/mode"){
            if(Modes[Chat[2,string],number]){
                Mode = Chat[2,string]    
            }
            else{
                err("Invalid mode")
            }
        }
    }

}

