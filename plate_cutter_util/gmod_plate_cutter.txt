@name Gmod Hunter Plate Cutter v2.1
@inputs 
@outputs 
@persist Ang Busy Mask:table RemoveThis:entity Entity:entity Mode:string Owner:entity ChangedMode Modes:table HoleModeState HoleData:table
@model models/hunter/blocks/cube025x025x025.mdl

#[
    Note for Fasteroid/expression2-public Github browsers: 
    
    This chip won't work without its #includes and supporting database.
    
    The includes can all be found alongside this file in plate_cutter_util/*.txt
    Just install them under the same location in your E2 folder and you should be good to go.
    
    Additionally, you'll need to pick up a copy of hunterplates_sorted.txt from my e2shared directory:
    https://github.com/Fasteroid/expression2-public/blob/master/e2shared/hunterplates_sorted.txt
    
]#

#include "plate_cutter_util/gmod_plate_database_sorted"
#include "plate_cutter_util/queuepropspawn"

if( first() ){
    
    Owner = owner()
    Mode  = "cut"
    Modes = table("cut"=1, "hole"=1)
    HoleModeState = 0
    
    function null(E:entity){}
    
    function err(Reason:string){
        holoEntity(0):soundPlay(2,1,"common/wpn_denyselect.wav")
        Busy = 0        
        print("[Prop Cutter] "+Reason)
    }
    
    propSpawnUndo(1)
    holoCreate(0)
    holoColor(0,vec(255,200,0),0)
    holoAng(0,ang())
    holoMaterial(0,"lights/white")
    holoEntity(0):setRenderMode(9)
    
    #holoCreate(3)
    #holoModel(3,"models/sprops/misc/origin.mdl")
    
    holoCreate(1,entity():toWorld(vec()))
    holoModel(1,"plane")
    holoAng(1,ang(0,0,90))
    holoScaleUnits(1,vec(100,100,100))
    holoMaterial(1,"lights/white")
    holoColor(1,vec(255),0)
    holoEntity(1):setRenderMode(9)

    holoCreate(2)
    holoModel(2,"plane")
    holoAng(2,ang(0,0,-90))
    holoScaleUnits(2,vec(100,100,100))
    holoMaterial(2,"lights/white")
    holoColor(2,vec(60),0)
    holoEntity(2):setRenderMode(9)
    
    holoParent(1,0)
    holoParent(2,0)
    
    holoCreate(3)
    holoColor(3,vec(255,0,0),100)
    holoMaterial(3,"lights/white")
    
    for(I=4,7){
        holoCreate(I)
        holoModel(I,"hq_icosphere")
        holoScale(I,vec(0.5))
        holoColor(I,vec(0,0,255),100)
        holoMaterial(I,"lights/white")
        holoEntity(I):setRenderMode(9)
    }
    
    for(I=8,12){
        holoCreate(I)
        holoModel(I,"hq_icosphere")
        holoScale(I,vec(0.5))
        holoColor(I,vec(0,255,0),100)
        holoMaterial(I,"lights/white")
        holoEntity(I):setRenderMode(9)
    }

    #holoModel(1,"models/maxofs2d/cube_tool.mdl")
    #holoColor(1,vec(255,0,0),100)
    runOnTick(1)
    #holoScale(1,vec(10,0.01,10))
    
    
    #########################
    ## 
    #  build( XSize:numbner, YSize:number, Corner:vector, Options:optionsTable )
    #     Spawns a plate of XSize by YSize.   
    #
    #  optionsTable extends table:
    #   | "origin" = World position of corner
    #   | "angles" = World angles of corner
    #   | "format" = Function to format spawned props with
    #   | "delete" = Prop to remove upon completion; may be left blank
    #
    function build(XSize,YSize,Corner:vector,Options:table){
        
        PlateObj = getClosestFit(round(XSize),round(YSize))
        local LTX = LTY = 0
        local XReal = PlateObj["x",number]
        local YReal = PlateObj["y",number]
        local RotationAng = ang(0,PlateObj["angle",number],0)
        
        local World = toWorldPosAng( 
            (Corner)*UNIT_SIZE, # local pos
            RotationAng,                                  # local ang
            Options["origin",vector],                     # world pos
            Options["angles",angle]                       # world ang
        )
        
        queuePropSpawn(
            PlateObj["model",string],
            World[1,vector] + PlateObj["offset",vector]:rotate(Options["angles",angle]) * UNIT_SIZE,
            World[2,angle]
        )
        
        if( XReal < XSize ){
            build(XSize-XReal,YReal,Corner+vec(XReal,0,0),Options)    
            LTX = 1
        }
        if( YReal < YSize ){
            build(XReal,YSize-YReal,Corner+vec(0,YReal,0),Options)
            LTY = 1
        }
        if( LTX & LTY ){ # degenerate case
            build(XSize-XReal,YSize-YReal,Corner+vec(XReal,YReal,0),Options)
        }  
    }    
    
    #########################
    ## 
    #  computeSnapping( )
    #     Predefines some variables.  Sorry they're global lol
    #    
    function computeSnapping(){
        FlatMin = Entity:boxMin():setZ(0)
        FlatSize = round( Entity:boxSize():setZ(0) / UNIT_SIZE )
        Origin = Entity:toWorld(FlatMin)
        
        #holoPos(3,Origin)
        #holoAng(3,Entity:angles())
        
        Forward = Owner:aimNormal()
        Up      = Entity:right()
        
        AngContext = quat(Forward,Up)
        TileAng = AngContext:toAngle()
        
        SpawnComplement = Entity:toLocal( Owner:aimPos() ) + FlatMin
        SpawnComplement = round( SpawnComplement / UNIT_SIZE )
        WorldPos = Entity:toWorld(SpawnComplement * UNIT_SIZE - FlatMin) 
        SpawnPos = round( Entity:boxSize():setZ(0) / UNIT_SIZE + SpawnComplement - 2 * Entity:boxCenter() / UNIT_SIZE )
    }
    
    # ------------ Mode Functions ------------ #
    
    #########################
    ## 
    #  cut( Init:boolean )
    #     Cutting mode.  Pass 1 to enable.
    #
    function cut(Init){
        
        if(Init){
            holoAlpha(1,100)
            holoAlpha(2,200)
            holoAlpha(0,0)
            return
        }
        
        if(changed(Entity)){
            holoPos(3,Entity:boxCenterW())
            holoAng(3,Entity:angles())
            holoScaleUnits(3,Entity:boxSize())    
            holoParent(3,Entity)
        }
        
        holoPos(0,WorldPos)
        holoAng(0,TileAng:rotateAroundAxis(Forward,Ang))   
                

        if(changed(Owner:keyAttack1()) & Owner:keyAttack1()){
            Busy = 1
            if(Ang == 0 | Ang == 180){
                if( !SpawnPos[1] | !(FlatSize[1]-SpawnPos[1]) | !(FlatSize[2]) ){
                    err("Nothing to cut here")
                    return
                }
                holoUnparent(3)
                build(SpawnPos[1],FlatSize[2],vec(),table(
                    "origin" = Origin,
                    "angles" = Entity:angles(),
                    "delete" = Entity
                ))
    
                build(FlatSize[1]-SpawnPos[1],FlatSize[2],vec(),table(
                    "origin" = Entity:toWorld(FlatMin+vec(SpawnPos[1],0,0)*UNIT_SIZE),
                    "angles" = Entity:angles(),
                    "delete" = Entity
                ))
            }
            elseif(Ang == 90 | Ang == 270){
                
                if( !FlatSize[1] | !(FlatSize[2]-SpawnPos[2]) | !(SpawnPos[2]) ){
                    err("Nothing to cut here")
                    return
                }
                holoUnparent(3)
                build(FlatSize[1],SpawnPos[2],vec(),table(
                    "origin" = Origin,
                    "angles" = Entity:angles(),
                    "delete" = Entity
                ))
    
                build(FlatSize[1],FlatSize[2]-SpawnPos[2],vec(),table(
                    "origin" = Entity:toWorld(FlatMin+vec(0,SpawnPos[2],0)*UNIT_SIZE),
                    "angles" = Entity:angles(),
                    "delete" = Entity
                ))
            } 
            holoEntity(0):soundPlay(1,1,"buttons/weapon_confirm.wav")
            soundPitch(1,180)
            return
        }
    }
    
    #########################
    ## 
    #  hole( Init:boolean )
    #     Hole cutter mode.  Pass 1 to enable.  WIP.
    #
    function hole(Init){
        
        if(Init){
            holoAlpha(1,0)
            holoAlpha(2,0)
            holoAlpha(0,150)
            holoScaleUnits(0,vec(5))
            HoleModeState = 0
            return
        }
    
        KeyAttack1 = changed(Owner:keyAttack1()) & Owner:keyAttack1()
    
        if( HoleModeState == 0 ){
            
            local EntChange = changed(Entity) 
            
            if( EntChange ){
                holoPos(3,Entity:boxCenterW())
                holoAng(3,Entity:angles())
                holoScaleUnits(3,Entity:boxSize())    
                holoParent(3,Entity)
            }
            
            if( EntChange | changed(SpawnComplement) ){
                holoPos(0,WorldPos+Entity:toWorldAxis(vec(2)))
                holoAng(0,TileAng)
                HoleData["pos",vector] = SpawnPos
                HoleData["complement",vector] = SpawnComplement
                HoleData["world",vector] = WorldPos
                HoleData["ent",entity] = Entity
                HoleData["entpos",vector] = Entity:pos()
            }
            
            if(KeyAttack1){
                HoleModeState++
                print("1")
                holoEntity(0):soundPlay(3,1,"buttons/lightswitch2.wav")
            }
            
        }
        else{
            
            if( HoleData["ent",entity] != Entity ){
                return
            }
            
            if( HoleData["ent",entity]:pos() != HoleData["entpos",vector] ){    
                HoleModeState = 0
                holoScaleUnits(0,vec(UNIT_SIZE/2))
                print("Entity moved, hole aborted.")
                owner():soundPlay(404,1,"buttons/button10.wav")
                return
            }
            
            if( changed(SpawnComplement) ){
                holoPos(0,(HoleData["world",vector]+WorldPos)/2)
                holoScaleUnits(0,( positive(SpawnPos-HoleData["pos",vector]):rotate(ang(0,90,90)) + vec(1,0,0)) * UNIT_SIZE)
                holoAng(0,TileAng)
            }       
            
            if(changed(Owner:keyAttack2()) & Owner:keyAttack2()){
                HoleModeState = 0
                holoScaleUnits(0,vec(UNIT_SIZE/2))
                return
            }
            
            if(KeyAttack1){
                
                holoUnparent(3)
                
                HoleModeState = 0
                holoScaleUnits(0,vec(UNIT_SIZE/2))
                Busy = 1
            
                local MinCorner = minVec(HoleData["pos",vector],SpawnPos)
                local MaxCorner = maxVec(HoleData["pos",vector],SpawnPos)
                local MinComplement = minVec(HoleData["complement",vector],SpawnComplement)
                local MaxComplement = maxVec(HoleData["complement",vector],SpawnComplement)
                
                local MinCorners = array(
                    vec(),
                    vec(MinCorner[1],0,0),
                    vec(MinCorner[1],FlatSize[2]+MaxComplement[2],0),
                    vec(MaxCorner[1],0,0)
                )
                
                local Sizes = array(
                    vec(MinCorner[1],FlatSize[2],0),
                    vec(MaxCorner[1]-MinCorner[1],FlatSize[2]+MinComplement[2],0),
                    vec(MaxCorner[1]-MinCorner[1],-MaxComplement[2],0),
                    FlatSize - vec(MaxCorner[1],0,0)
                )
                
                for(I=1, 4){
                    local Origin = Entity:toWorld(FlatMin + MinCorners[I,vector]*UNIT_SIZE)
                    local Size = Sizes[I,vector]
                    if(Size[1] & Size[2]){
                        build(Size[1],Size[2],vec(),table(
                            "origin" = Origin,
                            "angles" = Entity:angles(),
                            "delete" = Entity
                        ))
                    }
                }
                
                holoEntity(0):soundPlay(1,1,"buttons/weapon_confirm.wav")
                soundPitch(1,180)
                
                return
    
            }            
                     
        }
        
    }
    
}

Owner = owner()
Active = (Owner:weapon():type() == "weapon_crowbar")
DoneBusy = !Queue:count() & Busy

if(changed(Mode) | first()){
    print("init")
    Mode(1)
}

if(DoneBusy){
    Busy = 0
    Entity:propDelete()    
}

if(Active & !Busy){
    
    if(changed(Owner:keyAttack2()) & Owner:keyAttack2()){
        Ang = (Ang + 90)%360
    }
    
    Entity = Owner:aimEntity()
    
    if(Entity){    
        computeSnapping()
        Mode(0)
    }
    
    if(changed(Owner:lastSaidWhen())){
        Chat = Owner:lastSaid():explode(" ")
        if(Chat[1,string]=="/mode"){
            if(Modes[Chat[2,string],number]){
                Mode = Chat[2,string]    
            }
            else{
                err("Invalid mode")
            }
        }
    }

}

