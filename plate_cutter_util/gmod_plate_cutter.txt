@name Gmod Hunter Plate Cutter v2.6
@inputs 
@outputs 
@persist Ang Busy Mask:table RemoveThis:entity Entity:entity Mode:string Owner:entity ChangedMode Modes:table Helps:table
@persist ModeState ModePersist:table PropData:table
@persist ExtensionPlane:entity ShouldDelete
@persist [FlatMin,FlatSize,Forward,Up,SpawnComplement,WorldPos,SpawnPos]:vector Valid TileAng:angle
@model models/hunter/blocks/cube025x025x025.mdl

#[
    Note for Fasteroid/expression2-public Github browsers: 
    
    This chip won't work without its #includes and supporting database.
    Check the README in the repo for more details!
]#

#include "plate_cutter_util/gmod_plate_database_sorted"
#include "plate_cutter_util/queuepropspawn"

if( first() ){
    
    Owner = owner()
    Mode  = "cut"
    
    Modes = table(
        "cut" = "Cut new geometry",
        "hole" = "Remove rectangular regions", 
        "fill" = "Generate coplanar plates"
    )
    
    Helps = table(
        "cut" = "Left click to place cuts.\nRight click to rotate the cutting plane.", 
        "hole" = "Left click to set first and second corner.\nRight click to cancel.", 
        "fill" = "Left click to set first and second corner.\nRight click to cancel."
    )
    
    ModeState = 0
    
    print("--------------------------------------------------\n---           Fast's Hunter Plate Cutter           ---\n--------------------------------------------------\n")
    print("/help \t\t| How to use current mode")
    foreach(S:string,Desc:string = Modes){
        print("/mode "+S+"\t| "+Desc)
    }
    print(" \n")
    
    function err(Reason:string){
        holoEntity(0):soundPlay(2,1,"common/wpn_denyselect.wav")
        Busy = 0        
        print("[Prop Cutter] "+Reason)
    }

    function prnt(String:string){ 
        print("[Prop Cutter] "+String)
    }
    
    # this function is a bit mistleading; it actually checks for intersections from both sides
    function vector rayPlaneIntersect([Start Dir Pos Normal]:vector){
        A = Normal:dot(Dir)
        B = Normal:dot(Pos-Start)
        if(sign(A)==sign(B)){
            return Start+Dir*(B/A)
        }
        return vec(0)
    }
    
    propSpawnUndo(1)
    holoCreate(0)
    holoColor(0,vec(255,255,0),100)
    holoAng(0,ang())
    holoScaleUnits(0,vec(5))
    holoMaterial(0,"lights/white")
    holoEntity(0):setRenderMode(9)
    holoVisible(0,players(),0)
    
    holoCreate(1,entity():toWorld(vec()))
    holoModel(1,"plane")
    holoAng(1,ang(0,0,90))
    holoScaleUnits(1,vec(100,100,100))
    holoMaterial(1,"lights/white")
    holoColor(1,vec(255),100)
    holoEntity(1):setRenderMode(9)

    holoCreate(2)
    holoModel(2,"plane")
    holoAng(2,ang(0,0,-90))
    holoScaleUnits(2,vec(100,100,100))
    holoMaterial(2,"lights/white")
    holoColor(2,vec(60),200)
    holoEntity(2):setRenderMode(9)
    
    holoParent(1,0)
    holoParent(2,0)
    
    holoCreate(3)
    holoColor(3,vec(255,0,0),100)
    holoMaterial(3,"lights/white")

    runOnTick(1)
    
    
    #########################
    ## 
    #  build( XSize:numbner, YSize:number, Corner:vector, Options:optionsTable )
    #     Spawns a plate of XSize by YSize.   
    #
    #  optionsTable extends table:
    #   | "origin" = World position of corner
    #   | "angles" = World angles of corner
    #   | "format" = Function to format spawned props with
    #   | "delete" = Prop to remove upon completion; may be left blank
    #
    function build(XSize,YSize,Corner:vector,Options:table){
        
        PlateObj = getClosestFit(round(XSize),round(YSize))
        local LTX = LTY = 0
        local XReal = PlateObj["x",number]
        local YReal = PlateObj["y",number]
        local RotationAng = ang(0,PlateObj["angle",number],0)
        
        local World = toWorldPosAng( 
            (Corner)*UNIT_SIZE, # local pos
            RotationAng,                                  # local ang
            Options["origin",vector],                     # world pos
            Options["angles",angle]                       # world ang
        )
        
        queuePropSpawn(
            PlateObj["model",string],
            World[1,vector] + PlateObj["offset",vector]:rotate(Options["angles",angle]) * UNIT_SIZE,
            World[2,angle],
            Options["format",string]
        )
        
        if( XReal < XSize ){
            build(XSize-XReal,YReal,Corner+vec(XReal,0,0),Options)    
            LTX = 1
        }
        if( YReal < YSize ){
            build(XReal,YSize-YReal,Corner+vec(0,YReal,0),Options)
            LTY = 1
        }
        if( LTX & LTY ){ # degenerate case
            build(XSize-XReal,YSize-YReal,Corner+vec(XReal,YReal,0),Options)
        }  
    }    
    
    #########################
    ## 
    #  computeSnapping( )
    #     Predefines some variables.  Sorry they're global lol
    #    
    function computeSnapping(){
        
        Valid = Entity:model():find("models/hunter/plates") & !(Entity:model():find("tri")) & Entity:model():find("x")
        if(!Valid){
            return
        }
        
        FlatMin = Entity:boxMin():setZ(0)
        FlatSize = round( Entity:boxSize():setZ(0) / UNIT_SIZE )
        
        AimPos = rayPlaneIntersect(Owner:shootPos(),Owner:eye(),Entity:pos(),Entity:up())
        
        local LocalAim = Entity:toLocal( AimPos + Entity:boxCenter() ) / UNIT_SIZE
        Forward = Entity:up()
        Up      = Entity:right()
        
        local AngContext = quat(Forward,Up)
        TileAng = AngContext:toAngle()
        
        SpawnComplement = Entity:toLocal( AimPos ):setZ(0) + FlatMin
        SpawnComplement = round( SpawnComplement / UNIT_SIZE )
        WorldPos = Entity:toWorld(SpawnComplement * UNIT_SIZE - FlatMin + Entity:boxCenter()*vec(0,0,1)) 
        SpawnPos = round( Entity:boxSize():setZ(0) / UNIT_SIZE + SpawnComplement - 2 * Entity:boxCenter() / UNIT_SIZE + Entity:boxCenter()*vec(0,0,1) )
        
    }
    
    #########################
    ## 
    #  computeExtension( )
    #     Like computeSnapping but only snaps to the edges of props
    #    
    function computeExtension(){
        
        Valid = Entity:model():find("models/hunter/plates") & !(Entity:model():find("tri")) & Entity:model():find("x")
        if(!Valid){
            return
        }
        
        FlatMin = Entity:boxMin():setZ(0)
        FlatSize = round( Entity:boxSize():setZ(0) / UNIT_SIZE )
        
        local LocalAim = Entity:toLocal( Owner:aimPos() + Entity:boxCenter() ) / UNIT_SIZE
        Forward = vec(0,0,1) * sign( LocalAim:z() )
        Up      = Entity:right()
        
        local Diff = (FlatSize[2] - FlatSize[1])*sign(LocalAim[1])*0.5
        local Test = (vec(Diff,0,0)+LocalAim) * (1/FlatSize[2])
        
        if( abs(Test[1]) > abs(Test[2]) ){
            LocalAim[1] = FlatSize[1]*sign(LocalAim[1])*0.5
        }
        else{
            LocalAim[2] = FlatSize[2]*sign(LocalAim[2])*0.5
        }
        LocalAim = LocalAim * UNIT_SIZE
        
        local AngContext = quat(Forward,Up)
        TileAng = AngContext:toAngle()
        
        SpawnComplement = LocalAim:setZ(0) + FlatMin
        SpawnComplement = round( SpawnComplement / UNIT_SIZE )
        WorldPos = Entity:toWorld(SpawnComplement * UNIT_SIZE - FlatMin ) 
        SpawnPos = round( Entity:boxSize():setZ(0) / UNIT_SIZE + SpawnComplement - 2 * Entity:boxCenter() / UNIT_SIZE )
        
    }
    
    function vector entity:getBadHeightFix(){
        return Entity:boxCenter()*vec(0,0,1)  
    }
    
    function storePropData(E:entity){
        PropData["mat",string] = E:getMaterial()
        PropData["color",vector] = E:getColor()
        PropData["alpha",number] = E:getAlpha()
        #PropData["render",number] = E:getRenderMode() BOOO, THERE'S NO FUNCTION FOR THIS!
    }
    
    function applyPropData(E:entity){
        E:setMaterial( PropData["mat",string] )
        E:setColor( PropData["color",vector] )
        E:setAlpha( PropData["alpha",number])
    }
    
    # ------------ Mode Functions ------------ #
    
    #########################
    ## 
    #  cut( Init:boolean )
    #     Slicing mode.  Pass 1 to enable.
    #
    function cut(Init){
        
        if(Init){
            holoVisible(1,players(),1)
            holoVisible(2,players(),1)
            holoVisible(0,players(),0)
            ShouldDelete = 1
            return
        }
        
        computeSnapping()
        
        if(!Entity){ return }

        if(changed(Entity)){
            if( Valid ){
                holoPos(3,Entity:boxCenterW())
                holoAng(3,Entity:angles())
                holoScaleUnits(3,Entity:boxSize())    
                holoParent(3,Entity)
            }
            else{
                holoScale(3,vec(0))
            }
        }
        
        holoPos(0,WorldPos)
        holoAng(0,TileAng:rotateAroundAxis(Forward,Ang))   
                

        if(changed(Owner:keyAttack1()) & Owner:keyAttack1()){
            
            Origin = Entity:toWorld(FlatMin + Entity:getBadHeightFix())
            
            if(!Valid){
                err("Sorry, that prop is not supported (yet)")
                return
            }
            
            Busy = 1
            storePropData(Entity)
            if(Ang == 0 | Ang == 180){
                if( !SpawnPos[1] | !(FlatSize[1]-SpawnPos[1]) | !(FlatSize[2]) ){
                    err("Nothing to cut here")
                    return
                }
                holoUnparent(3)
                build(SpawnPos[1],FlatSize[2],vec(),table(
                    "origin" = Origin,
                    "angles" = Entity:angles(),
                    "format" = "applyPropData"
                ))
    
                build(FlatSize[1]-SpawnPos[1],FlatSize[2],vec(),table(
                    "origin" = Entity:toWorld(FlatMin+vec(SpawnPos[1],0,0)*UNIT_SIZE + Entity:getBadHeightFix()),
                    "angles" = Entity:angles(),
                    "format" = "applyPropData"
                ))
            }
            elseif(Ang == 90 | Ang == 270){
                
                if( !FlatSize[1] | !(FlatSize[2]-SpawnPos[2]) | !(SpawnPos[2]) ){
                    err("Nothing to cut here")
                    return
                }
                holoUnparent(3)
                build(FlatSize[1],SpawnPos[2],vec(),table(
                    "origin" = Origin,
                    "angles" = Entity:angles(),
                    "format" = "applyPropData"
                ))
    
                build(FlatSize[1],FlatSize[2]-SpawnPos[2],vec(),table(
                    "origin" = Entity:toWorld(FlatMin+vec(0,SpawnPos[2],0)*UNIT_SIZE + Entity:getBadHeightFix()),
                    "angles" = Entity:angles(),
                    "format" = "applyPropData"
                ))
            } 
            holoEntity(0):soundPlay(1,1,"buttons/weapon_confirm.wav")
            soundPitch(1,180)
            return
        }
    }
    
    #########################
    ## 
    #  hole( Init:boolean )
    #     Hole cutter mode.  Pass 1 to enable.
    #
    function hole(Init){
        
        if(Init){
            holoVisible(1,players(),0)
            holoVisible(2,players(),0)
            holoVisible(0,players(),1)
            holoScaleUnits(0,vec(5))
            holoScale(3,vec(0))
            ModeState = 0
            ShouldDelete = 1
            return
        }
    
        KeyAttack1 = changed(Owner:keyAttack1()) & Owner:keyAttack1()
    
        if( ModeState == 0 ){
            
            computeSnapping()
            if(!Entity){ return }
            local EntChange = changed(Entity) 
            
            if( EntChange ){
                if( Valid ){
                    holoPos(3,Entity:boxCenterW())
                    holoAng(3,Entity:angles())
                    holoScaleUnits(3,Entity:boxSize())    
                    holoParent(3,Entity)
                }
                else{
                    holoScale(3,vec(0))
                    holoUnparent(3)
                }
            }
            
            if( EntChange | changed(SpawnComplement) ){
                holoPos(0,WorldPos)
                holoAng(0,TileAng)
                ModePersist["pos",vector] = SpawnPos
                ModePersist["complement",vector] = SpawnComplement
                ModePersist["world",vector] = WorldPos
                ModePersist["ent",entity] = Entity
                ModePersist["entpos",vector] = Entity:pos()
            }
            
            if(KeyAttack1){
                ModeState++
                holoEntity(0):soundPlay(3,1,"buttons/lightswitch2.wav")
            }
            
        }
        else{
            
            if( Entity ){
                computeSnapping()
            }
            Entity = ModePersist["ent",entity]
            
            if( ModePersist["ent",entity]:pos() != ModePersist["entpos",vector] ){    
                ModeState = 0
                holoScaleUnits(0,vec(UNIT_SIZE/2))
                print("Entity moved, hole aborted.")
                owner():soundPlay(404,1,"buttons/button10.wav")
                return
            }
            
            if( changed(SpawnComplement) ){
                holoPos(0,(ModePersist["world",vector]+WorldPos)/2)
                holoScaleUnits(0,( positive(SpawnPos-ModePersist["pos",vector]):rotate(ang(0,90,90)) + vec(1,0,0)) * UNIT_SIZE)
                holoAng(0,TileAng)
            }       
            
            if(changed(Owner:keyAttack2()) & Owner:keyAttack2()){
                ModeState = 0
                holoScaleUnits(0,vec(UNIT_SIZE/2))
                return
            }
            
            if(KeyAttack1){
                
                holoUnparent(3)
                
                ModeState = 0
                holoScaleUnits(0,vec(UNIT_SIZE/2))
                Busy = 1
                storePropData(Entity)
            
                local MinCorner = minVec(ModePersist["pos",vector],SpawnPos)
                local MaxCorner = maxVec(ModePersist["pos",vector],SpawnPos)
                local MinComplement = minVec(ModePersist["complement",vector],SpawnComplement)
                local MaxComplement = maxVec(ModePersist["complement",vector],SpawnComplement)
                
                local MinCorners = array(
                    vec(),
                    vec(MinCorner[1],0,0),
                    vec(MinCorner[1],FlatSize[2]+MaxComplement[2],0),
                    vec(MaxCorner[1],0,0)
                )
                
                local Sizes = array(
                    vec(MinCorner[1],FlatSize[2],0),
                    vec(MaxCorner[1]-MinCorner[1],FlatSize[2]+MinComplement[2],0),
                    vec(MaxCorner[1]-MinCorner[1],-MaxComplement[2],0),
                    FlatSize - vec(MaxCorner[1],0,0)
                )
                
                for(I=1, 4){
                    local Origin = Entity:toWorld(FlatMin + MinCorners[I,vector]*UNIT_SIZE + Entity:getBadHeightFix())
                    local Size = Sizes[I,vector]
                    if(Size[1] & Size[2]){
                        build(Size[1],Size[2],vec(),table(
                            "origin" = Origin,
                            "angles" = Entity:angles(),
                            "delete" = Entity,
                            "format" = "applyPropData"
                        ))
                    }
                }
                
                holoEntity(0):soundPlay(1,1,"buttons/weapon_confirm.wav")
                soundPitch(1,180)
                
                return
    
            }              
        }
    }    
    
    #########################
    ## 
    #  fill( Init:boolean )
    #     Plate fill mode.  Pass 1 to enable.
    #
    function fill(Init){
        
        if(Init){
            holoVisible(1,players(),0)
            holoVisible(2,players(),0)
            holoVisible(0,players(),1)
            holoScale(3,vec(0))
            holoScaleUnits(0,vec(5))
            holoUnparent(3)
            ModeState = 0
            ShouldDelete = 0
            return
        }
    
        KeyAttack1 = changed(Owner:keyAttack1()) & Owner:keyAttack1()
    
        if( ModeState == 0 ){
            
            computeExtension()
            if(!Entity){ return }
            local EntChange = changed(Entity) 
            
            if( EntChange | changed(SpawnComplement) ){
                holoPos(0,WorldPos)
                holoAng(0,TileAng)
                ModePersist["ent",entity] = Entity
                ModePersist["entpos",vector] = Entity:pos()
                ModePersist["local",vector] = SpawnComplement
                ModePersist["world",vector] = WorldPos
                ModePersist["pos",vector] = SpawnPos
            }
            
            if(KeyAttack1){
                ModeState++
                ExtensionPlane = Entity
                holoEntity(0):soundPlay(3,1,"buttons/lightswitch2.wav")
            }
            
        }
        else{
            
            Entity = ModePersist["ent",entity]
            computeSnapping()

            
            if( ModePersist["ent",entity]:pos() != ModePersist["entpos",vector] ){    
                ModeState = 0
                holoScaleUnits(0,vec(UNIT_SIZE/2))
                print("Entity moved, fill aborted.")
                owner():soundPlay(404,1,"buttons/button10.wav")
                return
            }
            
            if( changed(SpawnComplement) ){
                
                holoPos(0,(ModePersist["world",vector]+WorldPos)/2)
                holoScaleUnits(0,( positive(SpawnPos-ModePersist["pos",vector]):rotate(ang(0,90,90)) + vec(1,0,0)) * UNIT_SIZE)
                holoAng(0,TileAng)
                
            }       
            
            if(changed(Owner:keyAttack2()) & Owner:keyAttack2()){
                ModeState = 0
                holoScaleUnits(0,vec(UNIT_SIZE/2))
                return
            }
            
            if(KeyAttack1){
                
                holoScaleUnits(0,vec(UNIT_SIZE/2))
                storePropData(Entity)
            
            #SpawnComplement = LocalAim:setZ(0) + FlatMin
            #SpawnComplement = round( SpawnComplement / UNIT_SIZE )
            
                local MinCorner = minVec(ModePersist["local",vector],SpawnComplement)
                local MaxCorner = maxVec(ModePersist["local",vector],SpawnComplement)
                
                Size = MaxCorner - MinCorner
                Origin = Entity:toWorld(round(MinCorner)*UNIT_SIZE - FlatMin - vec(0.5,0.5,0) + Entity:getBadHeightFix())
                holoPos(4,Origin)
                if(Size[1] & Size[2]){
                    Busy = 1
                    ModeState = 0
                    build(Size[1],Size[2],vec(),table(
                        "origin" = Origin,
                        "angles" = Entity:angles(),
                        "format" = "applyPropData"
                    ))
                    holoEntity(0):soundPlay(1,1,"doors/door_metal_medium_open1.wav")
                    soundPitch(1,130)
                }
                else{
                    err("Invalid plate size")   
                }
                
                return
    
            }              
        }
    }    
    
}

Owner = owner()
Active = (Owner:weapon():type() == "weapon_crowbar")
DoneBusy = !Queue:count() & Busy

if(changed(Mode) | first()){
    Mode(1)
}

if(DoneBusy){
    Busy = 0
    if(ShouldDelete){
        Entity:propDelete()  
    }  
}

if(Active & !Busy){
    
    if(changed(Owner:keyAttack2()) & Owner:keyAttack2()){
        Ang = (Ang + 90)%360
    }
    
    Entity = Owner:aimEntity()
     
    Mode(0)
    
    if(changed(Owner:lastSaidWhen())){
        Chat = Owner:lastSaid():explode(" ")
        if(Chat[1,string]=="/mode"){
            if(Modes[Chat[2,string],string]){
                Mode = Chat[2,string]    
                Owner:soundPlay(3,1,"buttons/button14.wav")
                prnt("Mode changed: "+Mode)
            }
            else{
                err("Invalid mode")
            }
        }
        elseif(Chat[1,string]=="/help"){
            prnt("Current Mode: "+Mode)
            prnt(Helps[Mode,string])
        }
    }

}

if( !holoEntity(3):isValid() ){
    holoCreate(3)
    holoColor(3,vec(255,0,0),100)
    holoMaterial(3,"lights/white")
}
